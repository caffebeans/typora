###                                                        TCP传输层

#### 头文件解析



![v2-590ccdac1ffd53a01264be6d8dfebfea_r](https://pic3.zhimg.com/v2-590ccdac1ffd53a01264be6d8dfebfea_r.jpg)



**序号**

表明发送的数据包的顺序，一般为上次发送包中的顺序号+1。若该数据包是整个TCP连接中的第一个包(SYN包)，则该值是随机生成的。

**确认号**

表明本端TCP已经接收到的数据，其值表示期待对端发送的下一个字节的序号。实际上告诉对方，在这个序号减1以前的字节已正确接收。若该数据包是整个TCP连接中的第一个包(SYN包)，则确认号一般为0。

**数据偏移**

表示以32位(4字节)为单位的TCP分组头的总长度(首部长度)，用于确定用户数据区的起始位置。在没有可变内容的情况下，**TCP头部的大小为20字节，对应该值为5**。

**标志位**

- 紧急标志位(URG)：开启时表明此数据包处于紧急状态应该优先处理
- 确认标志位(ACK)：开启时表明确认号有效，否则忽略确认号
- 推送标志位(PSH)：开启时表明应该尽快交付给应用进程，而不必等到缓存区填满才推送，比如 telnet 的场景
- 复位标志位(RST)：开启时表明TCP连接出现连接出现错误，数据包非法拒绝连接
- 同步标志位(SYN)：开启时表明连接建立的标志
- 终止标志位(FIN)：开启时表明释放一个连接

**紧急指针**
在紧急状态下(URG打开)，指出窗口中紧急数据的位置(末端)。

**选项(可变)**
用于支持一些特殊的变量，比如最大分组长度(MSS)。

**填充**
用于保证可变选项为32 bit的整数倍。

> 黑板：一般情况下TCP 头部为20字节，加上20字节的 IP头部，一个数据包至少包含40字节的头部

#### 三次握手流程



![v2-a2e876e218b1d29c3d181647e902ed1e_r](https://pic3.zhimg.com/v2-a2e876e218b1d29c3d181647e902ed1e_r.jpg)





#### 修改半连接的连接数

![image-20211111172746214](/Users/zhang/Library/Application Support/typora-user-images/image-20211111172746214.png)

![image-20211111172835315](/Users/zhang/Library/Application Support/typora-user-images/image-20211111172835315.png)



`cat cat tcp_max_syn_backlog`

1024个半连接（可以进行修改）

`cat /proc/sys/net/core/somaxconn`

128个连接

#### 四次挥手的过程

![v2-2764492101bafc3df775910dc09b65a2_r](https://pic3.zhimg.com/v2-2764492101bafc3df775910dc09b65a2_r.jpg)

**在释放连接时，由于TCP是全双工的，因此最后要由两端分别进行关闭，这个流程如下**



1、客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入FIN_WAIT_1状态。
2、服务器收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务器进入CLOSE_WAIT状态，而客户端进入FIN_WAIT2状态。
3、服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入LAST_ACK状态。
4、客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务器，确认序号为收到序号+1，服务器进入CLOSED状态，完成释放。

**问题1. 为什么是四次挥手**

发送FIN的一方就是主动关闭(客户端)，而另一方则为被动关闭(服务器)。
当一方发送了FIN，则表示在这一方不再会有数据的发送。
其中当被动关闭方受到对方的FIN时，此时往往可能还有数据需要发送过去，因此无法立即发送FIN(也就是无法将FIN与ACK合并发送)，
而是在等待自己的数据发送完毕后再单独发送FIN，因此整个过程需要四次交互。

**问题2. 什么是半关闭**

客户端在收到第一个FIN的ACK响应后，会进入FIN_WAIT2 状态时，此时服务器处于 CLOSE_WAIT状态，这种状态就称之为**半关闭**。
从半关闭到全关闭，需要等待第二次FIN的确认才算结束。此时，客户端要等到服务器的FIN才能进入TIME_WAIT，
如果对方迟迟不发送FIN呢，则会等待一段时间后超时，这个可以通过内核参数**tcp_fin_timeout**控制，默认是60s。

**问题3. 为什么服务器会有大量 closewait**

半关闭的状态下的服务器连接会处于 closewait 状态，直到服务器发送了FIN。
那么在应用层则是调用**socket.close()**会执行FIN的发送，如果服务器出现大量CLOSE_WAIT状态的连接，那么有可能的原因：

- 服务器压力过大，根本来不及调用close
- 存在连接泄露问题(Bug)，服务器未及时关闭连接

**问题4. timewait 会带来什么问题**

当客户端收到了对方的FIN时，会进入TIME_WAIT状态，此时会保持一段时间再进入CLOSE状态。
这么做的原因主要还是为了可靠的关闭连接。在将TCP 进行可靠性设计之时就考虑了许多网络的不稳定性的因素，比如：
***发送给对方的ACK 可能会无法及时收到，此时对方可能重传FIN过来，如果提前进入CLOSE则会返回RST而不是ACK，就会影响关闭流程。\***
因此 TIME_WAIT 状态默认会持续一段时间，直到确认不会再有重传的数据包之后再安全的关闭。

>黑板：这里timewait的持续时间默认是 2*MSL(总共1分钟)，这个MSL叫**Max Segment Lifetime**，也就是关于一个数据包在网络中传输的最大生命周期的预设。
>MSL默认是30s，当然这个值在现在已经可以大幅度缩减。可见在当时在设计之初，网络状况有多么的糟糕。

那么timewait会带来什么问题？
如果频繁的主动关闭连接，可能会产生大量 timewait，由于timewait 的连接占用了一个句柄及少量内存(4K)，那么就有可能会影响其他连接的建立，比如：
**出现 too many open files 异常..**

该如何解决：

- 重用连接，避免频繁关闭，比如使用连接池
- 参数调优，比如开启**tcp_tw_reuse**选项支持timewait连接的重复使用。

> 黑板：HTTP 协议里头发现了timewait的问题，于是在 HTTP 1.1 中定义了 KeepAlive 用来支持连接的重用。

**问题5. RST 是什么，为什么会出现**

RST 是一个特殊的标记，用来表示当前应该立即终止连接。以下这些情况都会产生RST：

- 向一个未被监听的端口发送数据
- 对方已经调用 close 关闭连接
- 存在一些数据未处理(接收缓冲区)，请求关闭连接时，会发送RST强制关闭
- 某些请求发生了超时

**做一些端口的扫描，如下：**

![v2-e42894f550aec43c27ab287e622c5f2e_r](https://pic3.zhimg.com/v2-e42894f550aec43c27ab287e622c5f2e_r.jpg)RST 机制有时候也会被利用，

> 端口开启，可接受SYN





![v2-f9b698ed43ca4d2d47ee5fe6eb191709_r](https://pic2.zhimg.com/v2-f9b698ed43ca4d2d47ee5fe6eb191709_r.jpg)

#### 传输层协议

> TCP是一种面向连接的传输层协议，提供可靠的传输服务。

传输层定义了主机应用程序之间端到端的连通性。传输层中最为常见的两个协议分别是传输控制协议TCP（Transmission Control Protocol）和用户数据报协议UDP（User Datagram Protocol）

`提供的功能 `

- 提供的可靠的字节流服务

- 能够对数据进行分割

- 提供了控流策略

	

> 黑板：一般情况下TCP 头部为20字节，加上20字节的 IP头部，一个数据包至少包含40字节的头部



